//
//  ShapeManager.swift
//  BlockCam
//
//  Created by Stuart Rankin on 1/14/20.
//  Copyright Â© 2020 Stuart Rankin. All rights reserved.
//

import Foundation
import UIKit

/// Class contains central data and attributes about node shapes.
class ShapeManager
{
    /// Initialize the manager.
    public static func Initialize()
    {
        //Right now, nothing to initialize.
    }
    
    /// Returns the minimum allowable pixel size (smaller takes more time and energy) for a given shape.
    /// - Parameter For: The shape whose minimum pixel size will be returned.
    /// - Returns: Minimum pixel size for the passed shape.
    public static func GetMinimumPixelSize(For Shape: NodeShapes) -> Int
    {
        if let Restriction = ShapeSizeRestrictions[Shape]
        {
            return Restriction
        }
        return 16
    }
    
    /// Holds the dictionary of minimum pixel sizes for various shapes. This is to restrict complex
    /// shapes from bogging down or freezing the program.
    private static let ShapeSizeRestrictions =
        [
            NodeShapes.RadiatingLines: 32,
            NodeShapes.Characters: 32,
    ]
    
    /// Table of shape categories and the shapes in them.
    private static let _ShapeCategories: [(CategoryName: String, List: [String])] =
        [
            ("Standard", [NodeShapes.Blocks.rawValue, NodeShapes.Spheres.rawValue, NodeShapes.Toroids.rawValue,
                          NodeShapes.Ellipses.rawValue, NodeShapes.Diamonds.rawValue, NodeShapes.Cylinders.rawValue,
                          NodeShapes.Capsules.rawValue, NodeShapes.Cones.rawValue,
                          NodeShapes.Pyramids.rawValue]),
            ("Polygonal", [NodeShapes.Stars.rawValue, NodeShapes.Polygons.rawValue]),
            ("Regular Solids", [NodeShapes.Tetrahedrons.rawValue, NodeShapes.Icosahedrons.rawValue]),
            ("Combined", [NodeShapes.Lines.rawValue, NodeShapes.CappedLines.rawValue, NodeShapes.StackedShapes.rawValue,
                          NodeShapes.RadiatingLines.rawValue, NodeShapes.PerpendicularSquares.rawValue,
                          NodeShapes.PerpendicularCircles.rawValue,
                          NodeShapes.SpherePlus.rawValue, NodeShapes.BoxPlus.rawValue,
                          NodeShapes.Random.rawValue,
                          NodeShapes.CombinedForRGB.rawValue, NodeShapes.CombinedForHSB.rawValue]),
            ("Complex", [NodeShapes.CharacterSets.rawValue, NodeShapes.Meshes.rawValue]),
            ("Varying", [NodeShapes.HueVarying.rawValue, NodeShapes.SaturationVarying.rawValue,
                         NodeShapes.BrightnessVarying.rawValue, NodeShapes.HueTriangles.rawValue]),
            ("Flat Shapes", [NodeShapes.Polygon2D.rawValue, NodeShapes.Rectangle2D.rawValue,
                             NodeShapes.Circle2D.rawValue, NodeShapes.Oval2D.rawValue,
                             NodeShapes.Oval2D.rawValue, NodeShapes.Diamond2D.rawValue,
                             NodeShapes.Star2D.rawValue]),
    ]
    /// Get the table of shape categories.
    public static var ShapeCategories: [(CategoryName: String, List: [String])]
    {
        get
        {
            return _ShapeCategories
        }
    }
    
    /// Returns a flat list of all shapes.
    /// - Parameter ExceptFor: List of shapes to exclude from the returned list.
    /// - Returns: List of all shapes.
    public static func ShapeFlatList(ExceptFor: [String]) -> [NodeShapes]
    {
        var List = [NodeShapes]()
        for (_, CatList) in _ShapeCategories
        {
            for Name in CatList
            {
                if !ExceptFor.contains(Name)
                {
                List.append(NodeShapes(rawValue: Name)!)
                }
            }
        }
        return List
    }
    
    /// Returns a flat list of all shapes.
    /// - Returns: List of all shapes.
    public static func ShapeFlatList() -> [NodeShapes]
    {
        var List = [NodeShapes]()
        for (_, CatList) in _ShapeCategories
        {
            for Name in CatList
            {
                List.append(NodeShapes(rawValue: Name)!)
            }
        }
        return List
    }
    
    /// Table of shapes that require more than one `SCNGeometry` node to create.case
    private static let _MultipleGeometryShapes =
    [
        NodeShapes.CappedLines, NodeShapes.StackedShapes, NodeShapes.HueVarying, NodeShapes.SaturationVarying,
        NodeShapes.BrightnessVarying, NodeShapes.PerpendicularCircles, NodeShapes.PerpendicularSquares,
        NodeShapes.CombinedForRGB, NodeShapes.CombinedForHSB, NodeShapes.Meshes, NodeShapes.RadiatingLines,
        NodeShapes.SpherePlus, NodeShapes.BoxPlus, NodeShapes.Random
    ]
    /// Get the table of shapes that are formed from more than one `SCNGeometry` node.
    /// - Returns: Table of shapes that require more than one `SCNGeometry` node.
    public static func MultipleGeometryShapes() -> [NodeShapes]
    {
        return _MultipleGeometryShapes
    }
    
    /// Holds a table of node shapes that take options.
    private static var _OptionsAvailable = [NodeShapes.Letters, NodeShapes.Meshes, NodeShapes.CappedLines, NodeShapes.Stars,
                                            NodeShapes.Blocks, NodeShapes.RadiatingLines, NodeShapes.Cones, NodeShapes.Ellipses,
                                            NodeShapes.HueVarying, NodeShapes.SaturationVarying, NodeShapes.BrightnessVarying,
                                            NodeShapes.Characters, NodeShapes.CharacterSets, NodeShapes.StackedShapes,
                                            NodeShapes.Polygons, NodeShapes.Rectangle2D, NodeShapes.Polygon2D,
                                            NodeShapes.Circle2D, NodeShapes.Oval2D, NodeShapes.Diamond2D, NodeShapes.Star2D,
                                            NodeShapes.Spheres, NodeShapes.SpherePlus, NodeShapes.BoxPlus, NodeShapes.Random,
                                            NodeShapes.Tetrahedrons, NodeShapes.Icosahedrons]
    /// Returns a table of node shapes that take options.
    public static var OptionsAvailable: [NodeShapes]
    {
        get
        {
            return _OptionsAvailable
        }
    }
    
    /// Determines if the passed shape takes options.
    /// - Parameter Shape: The shape to determine if options are available.
    /// - Returns: True if the passed shape takes options, false if not.
    public static func ShapeHasOptions(_ Shape: NodeShapes) -> Bool
    {
        return OptionsAvailable.contains(Shape)
    }
    
    /// Holds valid extruded shapes for sphere + shapes.
    private static var _ValidSpherePlusShapes =
    [
        NodeShapes.Blocks, NodeShapes.Spheres, NodeShapes.Cones, NodeShapes.Lines, NodeShapes.Capsules,
        NodeShapes.Cylinders
    ]
    
    /// Return all valid extruded shapes for sphere +.
    /// - Returns: Array of shapes that can be extruded.
    public static func GetValidSpherePlusShapes() -> [NodeShapes]
    {
        return _ValidStackingShapes
    }
    
    /// Holds valid extruded shapes for box + shapes.
    private static var _ValidBoxPlusShapes =
    [
        NodeShapes.Spheres, NodeShapes.Blocks, NodeShapes.Cones, NodeShapes.Lines, NodeShapes.Capsules,
        NodeShapes.Pyramids, NodeShapes.Cylinders
    ]
    
    /// Return all valid extruded shapes for box +.
    /// - Returns: Array of shapes that can be extruded.
    public static func GetValidBoxPlusShapes() -> [NodeShapes]
    {
        return _ValidBoxPlusShapes
    }
    
    /// Holds valid random shapes.
    private static var _ValidRandomShapes =
    [
        NodeShapes.Spheres, NodeShapes.Blocks, NodeShapes.Circle2D, NodeShapes.Rectangle2D
    ]
    
    /// Return all valid random shapes.
    /// - Returns: Array of shapes that can be used as random shapes.
    public static func GetValidRandomShapes() -> [NodeShapes]
    {
        return _ValidRandomShapes
    }
    
    /// Holds a list of all shapes that are available for the stacked shape set.
    private static var _ValidStackingShapes = [NodeShapes.Blocks, NodeShapes.Spheres, NodeShapes.Capsules,
                                               NodeShapes.Cylinders, NodeShapes.Cones, NodeShapes.Lines,
                                               NodeShapes.Polygons, NodeShapes.Ellipses, NodeShapes.Stars,
                                               NodeShapes.Polygon2D, NodeShapes.Circle2D, NodeShapes.Oval2D,
                                               NodeShapes.Rectangle2D, NodeShapes.Star2D]
    
    /// Get the list of valid shapes for stacked shapes.
    public static func ValidShapesForStacking() -> [NodeShapes]
    {
        return _ValidStackingShapes
    }
    
    /// Holds a table of slow (performant) shapes.
    private static var _SlowList = [NodeShapes.Flowers, NodeShapes.Letters, NodeShapes.CharacterSets,
                                    NodeShapes.Characters]
    /// Get a table of slow shapes.
    /// - Note:
    ///    - Slow shapes may cause over-heating of the device as well as memory crashes.
    ///    - Round shapes are notorious for slowing things down.
    public static var SlowList: [NodeShapes]
    {
        get
        {
            return _SlowList
        }
    }
    
    /// Determines if the passed shape is slow.
    /// - Parameter Shape: The shape to test for slowness (where testing consists of seeing if the shape is in
    ///                    the `SlowList`).
    /// - Returns: True if the shape is slow, false if not.
    public static func ShapeIsSlow(_ Shape: NodeShapes) -> Bool
    {
        return SlowList.contains(Shape)
    }
    
    /// Return a decorated, attributed string for the passed shape name.
    /// - Parameter From: The name of the node shape whose (potentially) decorated name will be returned.
    /// - Returns: Attributed string with potential decorations for the passed shape name.
    public static func DecoratedShapeName(From ShapeName: String) -> NSAttributedString?
    {
        if let Shape = NodeShapes(rawValue: ShapeName)
        {
            return DecoratedShapeName(For: Shape)
        }
        return nil
    }
    
    /// Return a decorated, attributed string for the passed shape.
    /// - Parameter For: The node shape whose (potentially) decorated name will be returned.
    /// - Returns: Attributed string with potential decorations for the passed shape name.
    public static func DecoratedShapeName(For Shape: NodeShapes) -> NSAttributedString
    {
        let Decorated = Shape.rawValue
        var SlowShape: NSAttributedString? = nil
        if ShapeIsSlow(Shape)
        {
            //            let SlowFont = FontManager.CustomFont(.NotoSansSymbols2, Size: 17.0)
            let SlowFont = UIFont.systemFont(ofSize: 17.0)
            let Attributes: [NSAttributedString.Key: Any] =
                [
                    .font: SlowFont as Any,
                    .foregroundColor: UIColor.systemRed as Any
            ]
            SlowShape = NSAttributedString(string: " ô", attributes: Attributes)
        }
        var OptionShape: NSAttributedString? = nil
        if ShapeHasOptions(Shape)
        {
            //let OptionFont = FontManager.CustomFont(.NotoSansSymbols2, Size: 17.0)
            let OptionFont = UIFont.systemFont(ofSize: 17.0)
            let Attributes: [NSAttributedString.Key: Any] =
                [
                    .font: OptionFont as Any,
                    .foregroundColor: UIColor.systemBlue as Any
            ]
            OptionShape = NSAttributedString(string: " ô", attributes: Attributes)
        }
        let Attributes: [NSAttributedString.Key: Any] =
            [
                .font: UIFont.systemFont(ofSize: 17.0) as Any,
                .foregroundColor: UIColor.black as Any
        ]
        let DecoratedString = NSMutableAttributedString(string: Decorated, attributes: Attributes)
        if SlowShape != nil
        {
            DecoratedString.append(SlowShape!)
        }
        if OptionShape != nil
        {
            DecoratedString.append(OptionShape!)
        }
        return DecoratedString
    }
    
    public static let SeriesFontMap =
        [
            ShapeSeriesSet.Flowers: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Arrows: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Snowflakes: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.SmallGeometry: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Stars: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Ornamental: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Things: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Computers: "NotoSansSymbols2-Regular",
            ShapeSeriesSet.Hiragana: "HiraginoSans-W6",
            ShapeSeriesSet.Katakana: "HiraginoSans-W6",
            ShapeSeriesSet.KyoikuKanji: "HiraginoSans-W6",
            ShapeSeriesSet.Hangul: "NotoSansCJKkr-Black",
            ShapeSeriesSet.Bodoni: "BodoniOrnamentsITCTT",
            ShapeSeriesSet.Greek: "Times-Bold",
            ShapeSeriesSet.Cyrillic: "Times-Bold",
            ShapeSeriesSet.Emoji: "NotoEmoji",
            ShapeSeriesSet.Latin: "NotoSans-Bold",
            ShapeSeriesSet.Punctuation: "NotoSans-Bold",
            ShapeSeriesSet.BoxSymbols: "NotoSans-Bold",
            ShapeSeriesSet.MusicalSymbols: "NotoSansSymbols2-Regular"
    ]
    
    public static let ShapeMap =
        [
            ShapeSeries.Flowers: ShapeSeriesSet.Flowers,
            ShapeSeries.Arrows: ShapeSeriesSet.Arrows,
            ShapeSeries.Snowflakes: ShapeSeriesSet.Snowflakes,
            ShapeSeries.SmallGeometry: ShapeSeriesSet.SmallGeometry,
            ShapeSeries.Stars: ShapeSeriesSet.Stars,
            ShapeSeries.Ornamental: ShapeSeriesSet.Ornamental,
            ShapeSeries.Things: ShapeSeriesSet.Things,
            ShapeSeries.Computers: ShapeSeriesSet.Computers,
            ShapeSeries.Hiragana: ShapeSeriesSet.Hiragana,
            ShapeSeries.Katakana: ShapeSeriesSet.Katakana,
            ShapeSeries.KyoikuKanji: ShapeSeriesSet.KyoikuKanji,
            ShapeSeries.Hangul: ShapeSeriesSet.Hangul,
            ShapeSeries.Bodoni: ShapeSeriesSet.Bodoni,
            ShapeSeries.Greek: ShapeSeriesSet.Greek,
            ShapeSeries.Cyrillic: ShapeSeriesSet.Cyrillic,
            ShapeSeries.Emoji: ShapeSeriesSet.Emoji,
            ShapeSeries.Latin: ShapeSeriesSet.Latin,
            ShapeSeries.Punctuation: ShapeSeriesSet.Punctuation,
            ShapeSeries.BoxSymbols: ShapeSeriesSet.BoxSymbols,
            ShapeSeries.MusicalNotion: ShapeSeriesSet.MusicalSymbols,
    ]
}

/// Supported node shapes for each node of the image.
/// - Note: The value of each case should be a human-readable, very short description of the shape. These values are used
///         to populate lists and text and the like.
enum NodeShapes: String, CaseIterable
{
    /// Block from SCNBox.
    case Blocks = "Blocks"
    /// Ellipses from custom geometry.
    case Ellipses = "Ovals"
    /// Extruded diamond shapes - custom property (based on `.Ellipses`).
    case Diamonds = "Diamonds"
    /// Regular polygons.
    case Polygons = "Polygons"
    /// Pyramids from SCNPyramid. Each node rotated due to SceneKit's default rotation of the node.
    case Pyramids = "Pyramids"
    /// Toruses from SCNTorus. Each node rotated due to SceneKit's default rotation of the node.
    case Toroids = "Toroids"
    /// Cylinders from SCNCylinder. Each node rotate due to SceneKit's default rotation of the node.
    case Cylinders = "Cylinders"
    /// Spheres from SCNSphere.
    case Spheres = "Spheres"
    /// Capsules from SCNCapsule. Each node rotate due to SceneKit's default rotation of the node.
    case Capsules = "Capsules"
    /// Cones from SCNCone.
    case Cones = "Cones"
    /// Tetrahedrons from SCNTetrahedron.
    case Tetrahedrons = "Tetrahedrons"
    /// Icosahedron from SCNIcosahedron.
    case Icosahedrons = "Icosahedron"
    /// Star shapes from SCNStar.Geometry.
    case Stars = "Stars"
    /// Each node uses three shapes, one for red, one for green, and one for blue.
    case CombinedForRGB = "RGB"
    /// Each node uses three shapes, one for hue, one for saturation, and one for brightness.
    case CombinedForHSB = "HSB"
    /// Not currently implemented
    case Meshes = "Mesh"
    /// Each node is an extruded letter.
    case Letters = "Letters"
    /// Extruded characters.
    case Characters = "Characters"
    /// Each node is a line.
    case Lines = "Lines"
    /// Each node is a line with a sphere on top.
    case CappedLines = "Capped Lines"
    /// Each node consists of radiating lines.
    case RadiatingLines = "Radiating Lines"
    /// Each node's shape depends on the original hue.
    case HueVarying = "Hue Varying"
    /// Each node's shape depends on the original saturation.
    case SaturationVarying = "Saturation Varying"
    /// Each node's shape depends on the original brightness.
    case BrightnessVarying = "Brightness Varying"
    /// Perpendicular square shapes.
    case PerpendicularSquares = "Perpendicular Squares"
    /// Perpendicular circle shapes.
    case PerpendicularCircles = "Perpendicular Circles"
    /// Pointy triangles that point to the hue of the color they represent.
    case HueTriangles = "Hue Triangles"
    /// Stylized flowers.
    case Flowers = "Stylized Flower"
    /// Pre-defined character sets.
    case CharacterSets = "Character Sets"
    /// Stacks of shaped oriented in the prominence dimension.
    case StackedShapes = "Stacked Shapes"
    /// Two-dimensional polygons.
    case Polygon2D = "2D Polygon"
    /// Semi-2D rectangle.
    case Rectangle2D = "2D Rectangle"
    /// Semi-2D circle.
    case Circle2D = "2D Circle"
    /// Semi-2D ellipse.
    case Oval2D = "2D Ellipse"
    /// Semi-2D star.
    case Star2D = "2D Star"
    /// Semi-2D diamond.
    case Diamond2D = "2D Diamond"
    /// Sphere plus an extruded shape.
    case SpherePlus = "Sphere +"
    /// Box plus an extruded shape.
    case BoxPlus = "Box +"
    /// Specified shape with randomness.
    case Random = "Random"
}

enum ShapeSeriesSet: String, CaseIterable
{
    case Flowers = "â»â¾â¢â¥âââ½â¤ðâºâ¿ðµâð¨ðªð¶âââââ¼ð»ðºð¹ð¸ð·ðââ¥ð¼áª¥ê¥ê¤ê®âââ¦"
    case Snowflakes = "âââð¾â"
    case Arrows = "â®â¯â§â¬â¯â®ââ¨â®ââ¬â®ðâ©âªâ®â®â®°âªðâ®±â®¶â®´â­ªâ¬ð¡ââ­¯â©â¦ââ®â¬â®â®â¬ð £â®â®â³âââââ®â¬â¬â¬â¬âââ¬ââ¬â¬â¢â³â¶âµâ´â¹â¾"
    case SmallGeometry = "âââââ¾ââââ¦¿â¬¬âââ¬â¯â¬¢ð¾ðâ¬ â¬¡â¬â­ââââðâ¬¯âââðâªððâââââ¬ðââ¯â°â â¡â¢â£â¬â¤â¥â¦â§â¨â©â§â©â¨"
    case Stars = "â¦â§â©âªâ¯ââ®â¹â¶ðââ´âµââºðâ·ððâ¼â¸ðâ°â¬â«â­"
    case Ornamental = "ððð±ðââð§âðð¤ðð¦ð¥â¢âð¹ð¢ððâ§ð â¡ððâ¦â¤ð°ââ£â ð£ðâðð¡ðððµðððð"
    case Things = """
    ð´ð§ð¶â³ð ð¹ðððâðð±ð­ð¾âð°âððð°ð«ð¢â¾ð·ðð­ð©ðââ±ðºðð¡ð§ð¢ðð¦ð­âð¹ð®ðð¦ð³ð¾ððð¬ð»ððð­ð¿ðððð³ððð±âââââââ¨âðâð¦ððð½ð®ððð­ðð½ðªð²ð²ðâðððªððð½ð¯ð¬ðð·âðð¬ð«ð¿ðð¶ðªââðââð©ðððð ðº
    """
    case Computers = "ðð¹ð¦ð®ð°âð¶â¡ð¿ðâ¨ðâð®ððð»ð«ð²ð¨â§ðð¬ðµâðð¸â«âðâ¦ð´ð·â"
    case Hiragana = """
    ããããããããããããããããããããããããããã ã¡ã¢ã¤ã¥ã¦ã§ã¨ã©ãªã«ã¬ã­ã®ã¯ã°ã±ã²ã³ã´ãµã¶ã·ã¸ã¹ãºã»ã¼ã½ã¾ã¿ãããããããããããããããã
    """
    case Katakana = """
    ã¢ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã°ã±ã²ã³ã´ãµã¶ã·ã¸ã¹ãºã»ã¼ã½ã¾ã¿ãããããããããããããããããããããããããããããããã ã¡ã¢ã¤ã¦ã¨ã©ãªã«ã¬ã­ã¯ã°ã±ã²ã³ã´
    """
    case KyoikuKanji = """
    ä¸ä¸ä¸ä¸ä¸ä¸ä¸ä¸ä¸ä¸¡ä¸¦ä¸­ä¸¸ä¸»ä¹ä¹ä¹ä¹±ä¹³äºäºäºäºäºäº¡äº¤äº¬äººä»ä»ä»ä»ä»ä»ä»£ä»¤ä»¥ä»®ä»²ä»¶ä»»ä¼ä¼ä¼ä¼¼ä½ä½ä½ä½ä½ä½ä½ä½¿ä¾ä¾ä¾¡ä¾¿ä¿ä¿ä¿¡ä¿®ä¿³ä¿µåååååå¤åå¥å´åå·ååååªåååååååå¥å¨å«å¬å­å±åµå·å¸åååååå¬å·å¦åºååååååå¤å¥å©å¶å·å¸å»ååå¯å²åµåååå å©åªå´å¹åååååå¢å¤ååååºå»åååååååååå°å±åµååå³å»ååååååå£å¤å¥å¯å°å²å³å·å¸åååååååå¦å¸åå¨å³å¼å½ååå¡å±ååååå¶å¨ååå å£å°å²å³åºå½ååå§å¨å°åååååååºå å ±å ´å¡©å¢å¢å¢å£«å£°å£²å¤å¤å¤å¤å¤å¤å¤¢å¤§å¤©å¤ªå¤«å¤®å¤±å¥å¥®å¥³å¥½å¦¹å¦»å§å§å§å§¿å©¦å­å­å­å­å­£å­¦å­«å®å®å®å®å®å®å®å®å®å®å®å®¢å®£å®¤å®®å®³å®¶å®¹å®¿å¯å¯å¯å¯å¯å¯¸å¯ºå¯¾å°å°å°å°å°å°å°å°±å°ºå±å±å±å±å±å±å±¤å±±å²©å²¸å³¶å·å·å·£å·¥å·¦å·®å·±å·»å¸å¸å¸å¸«å¸­å¸¯å¸°å¸³å¸¸å¹å¹²å¹³å¹´å¹¸å¹¹å¹¼åºåºåºåºåºåºåº¦åº§åº«åº­åº·å»¶å»ºå¼å¼å¼å¼å¼å¼±å¼µå¼·å½å½¢å½¹å¾å¾å¾å¾å¾å¾å¾å¾å¾©å¾³å¿å¿å¿å¿å¿å¿ å¿«å¿µææ¥æ§æ©æ¯æªæ²ææ³æææææ£æ²æææ¦æ¸æææææ¹æ¿æææææææ¡æ¾ææææ¨ææ¡æ¢æ¥æ¨ææ®æææ¯æ¹æ¾æ¿æææææ£æ¬æ°æ´æµæææ­æ°æ¹ææææ¥æ§æ©æææææ æ¥æ¨æ­æ¼ææ©æ¯æ´ææææ®æ´ææ²æ¸æææææææææ¨æªæ«æ¬æ­æºææææ¡æ¥æ±æ¾æ¿ææææææ±æ»æ æ ¡æ ªæ ¹æ ¼æ¡æ¡æ¢æ¢°æ£æ£®æ¤æ¤æ¥­æ¥µæ¥½æ§æ§æ¨æ¨¡æ¨©æ¨ªæ¨¹æ©æ©æ¬ æ¬¡æ¬²æ­æ­¢æ­£æ­¦æ­©æ­¯æ­´æ­»æ®æ®µæ®ºæ¯æ¯æ¯æ¯æ¯æ°æ°æ°æ°´æ°·æ°¸æ±æ± æ±ºæ±½æ²³æ²¹æ²»æ²¿æ³æ³æ³¢æ³£æ³¨æ³³æ´æ´æ´»æ´¾æµæµæµ´æµ·æ¶æ¶²æ·±æ··æ¸æ¸æ¸æ¸©æ¸¬æ¸¯æ¹æ¹¯æºæºæºæ¼æ¼æ¼¢æ½æ½®æ¿ç«ç¯ç°ç½ç­ç¹ç¡ç¶ç¼ç§çç±çç¶çççç§ç©ç¹ç¬ç¯ç¶ç¬çççç­ç¾çççç£ç¨ç°ç±ç³ç·çºç»çççç¥çªç°ççççºç»ç½ç¾ççç®ç¿çççç®ç´ç¸ççççç¼çç¢ç¥ç­ç³ç ç ç ´ç¢ºç£ç¤ºç¤¼ç¤¾ç¥ç¥ç¥ç¥¨ç¥­ç¦ç¦ç§ç§ç§ç§ç§ç§»ç¨ç¨ç¨®ç©ç©ç©´ç©¶ç©ºçªç«ç« ç«¥ç«¶ç«¹ç¬ç¬ç¬¬ç­ç­ç­ç­ç­ç®ç®¡ç®±ç¯ç¯ç°¡ç±³ç²ç²¾ç³ç³¸ç³»ç´ç´ç´ç´ç´ç´ç´ç´ ç´°çµçµçµçµçµ¦çµ±çµµçµ¶çµ¹ç¶ç¶¿ç·ç·ç·ç·¨ç·´ç¸¦ç¸®ç¸¾ç¹ç½ªç½®ç½²ç¾ç¾ç¾¤ç¾©ç¾½ç¿ç¿èèèèè³èèè·èè¥è²èºèèè¸è½èè³è¸è¹èè£è¨èªè³èèèèªè¹è¯è²è±è¸è½è¥è¦è±è¶èè·èè½èèè¸èµè¬è«èè¡è¡è¡è¡è¡è¡è¡£è¡¨è£è£è£è£è£½è¤è¥¿è¦è¦è¦è¦è¦è¦§è¦ªè¦³è§è§£è¨è¨è¨è¨è¨è¨ªè¨­è¨±è¨³è¨¼è©è©è©¦è©©è©±èªèªèªèªèª èª¤èª¬èª­èª²èª¿è«è«è«¸è¬è¬è­è­¦è­°è­·è°·è±è±è±¡è²è² è²¡è²§è²¨è²¬è²¯è²´è²·è²¸è²»è²¿è³è³è³è³è³è³ªèµ¤èµ°èµ·è¶³è·¯èº«è»è»è»¢è»½è¼ªè¼¸è¾è¾²è¾ºè¿è¿è¿°è¿·è¿½éééééé é£é±é²éééééé é©é¸éºé¡é¨éµé·é½ééé¸éééééééé±ééé­é¼é²é¡é·ééééé¢é£é²éééé¢é¤é¸éºé½ééééééé£é¨éªé²é»éééé¢é©é³é é é é é ­é¡é¡é¡é¡é¡é¢¨é£é£é£¯é£²é£¼é¤é¤¨é¦é¦¬é§é¨éª¨é«é­é³¥é³´éº¦é»é»é¼»
    """
    case Hangul = """
    ã±ã´ã·ã¹ãããããããããããããããããã ã¡ã£ã²ã¸ãããããããããããã¢ãê°ëë¤ë§ë²ìì´ì ì²í í¬ì½í¸ê¾¸ëìì¨ì¯
    """
    case Bodoni = """
    !"#$%&()*+,ï¿½./012356789:;<=>?@ABCDEFGHIJKLMNOPQRSTVWXYZ][\
    ^_`abcdefghijklmnopqrstuvwxyz{|}â Â°Â¢Â®Â©â¢Â´Â¨â ÃÃâÂ±â¤â¥Â¥ï¿½âââÏâ«â
    """
    case Greek = """
    ÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿ÏÏÏÏÏÏÏÏÏ
    """
    case Cyrillic = """
    ÐÐ°ÐÐ±ÐÐ²ÐÐ³ÐÐ´ÐÐµÐÑÐÐ¶ÐÐ·ÐÐ¸ÐÐ¹ÐÐºÐÐ»ÐÐ¼ÐÐ½ÐÐ¾ÐÐ¿Ð ÑÐ¡ÑÐ¢ÑÐ£ÑÐ¤ÑÐ¥ÑÐ¦ÑÐ§ÑÐ¨ÑÐ©ÑÐªÑÐ«ÑÐ¬ÑÐ­ÑÐ®ÑÐ¯Ñ
    """
    
    case Emoji = """
    ââ¹âââ°â³ââââºââââââââââââ â£â¥â¦â¨â»â¿ââ â¡â½â¾âââââªâ²â³âµâºâ½â
    ââââââââ¨â³â´âââ¤â°â¿â­ã°ã½ããðððððð¯ð²ð³ð´ðµð¶ð·ð
    ðððððððððððððððððð ð°ð±ð´ðµ
    ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ððððððððððððððð
    ððððððððððð°ðððððð ð¡ð¢ð£ð¤ð¥ð¦ð§ð¨
    ððððð¸ð­ðªð©ð«ð¬ð®ð¯ð±ð²ð³ð»ðµð¶ð·ðºððððð
    ð§ðððððððððððð ð¥ð¨ð©ð¬ð«ð®ð¯ð°ð±ð²ð³
    ðð¯ðð»ð´ðµð¶ðð·ð¸ð¹ðºð¼ð½ð¾ððð¢ð£ð«ð¬ð­ð®ð°ðð¥ð¦
    ð¢ðð¦ðð ð¡ð¤ðð£ð¥ð¹ððððððððððððð©ð°ðºð®ð´ð»
    ððððð§ð±ð²ðµðððð¬ð¯ð¶ð­ð³ð¨ð«ð¸ð¼ð¾ð·ðððð
    ððð¢ð£ð¤ðð§ð«ð ð©ððªð®ð´ðµð·ð¾ððºð½ð¿ð»ððð¨ð¶ð¹ððð¡ð¦
    ððð£ð¤ðððð³ððð¡ð¢ðð«ðð ðððððððððð
    ð¥ðªðºððððððððð´ðð¸ð¹ðµð¬ð¦ð¨ð©ð°ð²ð¯ð±ð§ð®
    ðð·ððððð¡ðºðððððððð°ð¶ððð¹ð¼ð£ð»ððð ð¦ð®
    ðððð¢ððð²ð³ð¼ðððððððð§ð©ð¤ð¥ðð¢ó¾¬ð¨ðððððð¤ð¦
    ð´ð»ð½ðððð¨ð©ð±ð¾ð®ð°ðð§ðªó¾¨ð¯ð¥ððð ð¢ð£ð¡ó¾®ððð
    ðªð«ð­ð¼ð¹ó¾¦ðó¾©ó¾«ð ððððððððð­ðððð²ðð³ððð
    ð¼ððððð¬ððð¦ð°ð¿ðð­ð¶ð·ðµð¡ð£ðð½ð¾ðó¾¥ó¾§ó¾ªó¾­ð¤ð¯
    ðºð¬ðð¸ð²ðððð³ðððâððððð±ð²ââðððððððâ
    ðð
    """
    
    case Latin = """
    !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`\
    abcdefghijklmnopqrstuvwxya{|}~Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«âªâ«â¯
    Â¬Â­Â­Â®Â¯Â°Â±ÂºÂ¹Â²Â³Â´ÂµÃÂ¶Â·Â¸Â»Â½Â¾Â¼ÃÃÃÃÃÃÃÃÃÃÃÃÃÂ­Â¿ÃÃÃÃÃÃÃÄÃÃÃ¢Ã½ÃÃÃÃ®Ã±ÃµÃ¸Ã¿ÄÃÃ Ã¡Ã¦Ã§Ã­Ã°Ã´Ã»Ã¤ÃªÃ«Ã¯Ã²Ã¶Ã¼Ä
    Ä©Ä­Ä®Ä°ÄÄÄÄÄªÄÄÄÄÄ Ä«Ä¯Ä²ÄÄÄÄÄÄÄÄ¤Ä§Ä¬ÄÄÄÄÄÄÄ¢Ä£Ä¥Ä¦Ä±Ã£Ã¥Ã¨Ã¬Ã³Ã·Ã¾ÃÃÃºÄÄÄÃÃÃÄÄ¨ÄÃ©Ã¹ÄÄÄÄ¡Ä¸ÄºÄ¼ÅÅÅ
    ÅÅÅÅÅÅÅÅÅÅÅÅÅ¬ÅÅÅÄ³ÄµÄ¹Ä½Ä¾ÅÅÄ´ÎÄ¶Ä·Ä¿ÅÅÄ»ÅÅÅÅÅÅ Å¥Å§ÅµÅ«Å¯Å±Å³Å¶Å¼Ç¼ÅÅÈÅªÅ®Å°Å²Å¹Å½Å¾Ç½ÅÅ¦Å´ÅºÅ»ÈÅÅ¡ÈÅ¤Å¨Å­Å·ÇºÇ¾Ç¿
    â¿ââââ â¤ââ®âââ«âï¬â¸â¬ââ¦âââââ¤â¥â·â£â§â¢âââÎÎÅÅ¸ÈâÎÅ©Å¿ÎÎÆÇ»Îâ´ÎÎââï¬ââââââââââ¡â¢â¼ââµâ â°âºâ¦â²â³â¹
    """
    
    case Punctuation = """
    Â¦'.@â#(:;=<?_[`~,Â¢Â£Â¡{Â§}%Â½&*/$+>]^")-!|â\
    Â¯Â´Â¶Â¨Â«Â®Â°Â·Â¬Â¥Â©Â±Â¼Â¤Â»Â¾â°ââ«Â¿âââââ¢â â¦â³â¹âââ²âºââ¦ââââââ â¡â¼â¬â¢ââ
    ââ¤â§âââââµâ®ââââ¥âââ¤È·â®â¯ââ¡â²â¹â¢â¥â â­â°â±â³ââ¦â©â¨â´âââââ¡ââ
    """
    
    case BoxSymbols = """
    ââ¦âââââââââ¤â´â¬ââ¼âââââââ¦ââââââ ââââââ¡â¢â£â¤âªâ¬â¥â©â«â¨â§âââââââââ â¡ââ
    """
    
    case MusicalSymbols = """
    ððððððððððððððððððððððððððððððððð ð¡ð¢ð£ð¤â­â®â¯ððððð ð¡ð¢ð£ð¤ð¥ð¦ð©ðªð«ð¬ð­ð®ð¯ð°ð±ð²ð³ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ðððððððððððððððððð
    ððððððððððððð¡ð¢ð®ð¯ð°ð±ð²ð³ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ðððððððððððððððð
"""
}

/// Pre-defined sets of characters.
enum ShapeSeries: String, CaseIterable
{
    /// Flower shapes.
    case Flowers = "Flowers"
    /// Snowflake (or snow-related) shapes.
    case Snowflakes = "Snowflakes"
    /// Arrow shapes.
    case Arrows = "Arrows"
    /// Small geometric figures.
    case SmallGeometry = "Small Geometric Shapes"
    /// Star and sun shapes.
    case Stars = "Stars"
    /// Ornamental characters.
    case Ornamental = "Ornamental"
    /// Miscellaneous things.
    case Things = "Things"
    /// Comptuer-related shapes.
    case Computers = "Computer-Related"
    /// Hiragana characters.
    case Hiragana = "Hiragana"
    /// Katakana characters.
    case Katakana = "Katakana"
    /// Grade school kanji.
    case KyoikuKanji = "Grade School Kanji"//"KyÅiku Kanji"
    /// Hangul characters.
    case Hangul = "Hangul"
    /// Bodoni ornaments.
    case Bodoni = "Bodoni Ornaments"
    /// Latin characters.
    case Latin = "Latin Letters"
    /// Greek characters.
    case Greek = "Greek Letters"
    /// Cyrillic characters.
    case Cyrillic = "Cyrillic Letters"
    /// Emoji charactes.
    case Emoji = "Emoji"
    /// Punctuation marks.
    case Punctuation = "Punctuation"
    /// Symbols used to draw boxes.
    case BoxSymbols = "Box Symbols"
    /// Symbols used for musical notation.
    case MusicalNotion = "Musical Noation"
}


